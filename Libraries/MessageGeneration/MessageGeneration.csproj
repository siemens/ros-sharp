<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<TargetFramework>net8.0</TargetFramework>
		<OutputType>Library</OutputType>
		<GenerateAssemblyInfo>false</GenerateAssemblyInfo>
	</PropertyGroup>
	<PropertyGroup>
		<AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
		<AssemblyTitle>MessageGeneration</AssemblyTitle>
		<Description>.NET Library for generating C# source code for ROS message/service/action</Description>
		<Company>Siemens AG</Company>
		<Product>ROS#</Product>
		<Copyright>Copyright © 2024</Copyright>
		<AssemblyVersion>2.0.0.0</AssemblyVersion>
		<FileVersion>2.0.0.0</FileVersion>
	</PropertyGroup>
	<ItemGroup>
		<PackageReference Include="Microsoft.CSharp" Version="4.7.0" />
		<PackageReference Include="System.Data.DataSetExtensions" Version="4.5.0" />
	</ItemGroup>
	<Target Name="CopyToCombinedOutput" AfterTargets="Publish">
		<!-- Copy the new DLLs to the combined output folder -->
		<ItemGroup>
			<NewDllFiles Include="$(OutputPath)\publish\*.dll" />
		</ItemGroup>
		<Copy SourceFiles="@(NewDllFiles)" DestinationFolder="$(SolutionDir)CombinedOutput" />
	</Target>

	<!-- Following two Target tags copy updated source to the unity package after each build depending on the OS.-->
	<Target Name="PostBuildMessageGenerationWin" AfterTargets="PostBuildEvent" Condition=" '$(OS)' == 'Windows_NT' ">
		<PropertyGroup>
			<TargetDir>$(SolutionDir)\..\\com.siemens.ros-sharp\\Runtime\\Libraries</TargetDir>
			<PackLibraryDir>$(SolutionDir)\..\\com.siemens.ros-sharp\\Runtime</PackLibraryDir>
		</PropertyGroup>
		<Exec Command="powershell.exe -NonInteractive -executionpolicy Unrestricted -command &quot;$solutionDir = '$(SolutionDir)';$sourceDirs=Join-Path $solutionDir '\MessageGeneration';$targetDir= Join-Path $solutionDir '\..\com.siemens.ros-sharp\Runtime\Libraries';$packLibraryDir= Join-Path $solutionDir '\..\com.siemens.ros-sharp\Runtime';Remove-Item -Recurse -Force '$(TargetDir)\MessageGeneration';New-Item -ItemType Directory -Path '$(TargetDir)\MessageGeneration' | Out-Null;Get-ChildItem -Path $sourceDirs -Recurse -File -Exclude 'bin','obj','Properties' -Include *.cs | ForEach-Object {$relativePath=$_.FullName.Substring($_.FullName.IndexOf('Libraries'));$destination=Join-Path '$(PackLibraryDir)' $relativePath;$null=New-Item -ItemType Directory -Path (Split-Path $destination) -Force;Copy-Item $_.FullName -Destination $destination -Force};$foldersToDelete=@('obj','Properties');Get-ChildItem -Path '$(TargetDir)' -Recurse -Directory | Where-Object {$foldersToDelete -contains $_.Name} | ForEach-Object {Remove-Item $_.FullName -Recurse -Force};#Get-ChildItem -Path '$(TargetDir)' -Recurse&quot;" />
		<Message Text="Updated UPM->MessageGeneration." Importance="High" />
	</Target>

	<Target Name="PostBuildMessageGenerationNonWin" AfterTargets="PostBuildEvent" Condition=" '$(OS)' != 'Windows_NT' ">
		<PropertyGroup>
			<SolutionDir>$(SolutionDir)</SolutionDir>
			<TargetDir>$(SolutionDir)/../com.siemens.ros-sharp/Runtime/Libraries</TargetDir>
			<PackLibraryDir>$(SolutionDir)/../com.siemens.ros-sharp/Runtime</PackLibraryDir>
		</PropertyGroup>
		<Exec Command="mkdir -p '$(TargetDir)' &amp;&amp; find . -path './MessageGeneration' -prune -o -type f -name '*.cs' -exec cp --parents {} '$(PackLibraryDir)' \; &amp;&amp; find '$(TargetDir)' -type d \( -name 'bin' -o -name 'obj' -o -name 'Properties' \) -exec rm -r {} + &amp;&amp; find '$(TargetDir)' -type d -empty -delete" />
		<Message Text="Updated UPM->MessageGeneration." Importance="High" />
	</Target>

	<!-- Both versions do the same thing. They are written in one-line syntax due to XML limitations. Here's a more readable syntax:-->
	<!--
	    # Siemens AG 2024 - Author: Mehmet Emre Cakal <emre.cakal@siemens.com>
        # As a 'ps1' file, run from root folder! (ros-sharp\) 

        # Define the source directories
        $sourceDirs = @("Libraries\MessageGeneration", "Libraries\RosBridgeClient", "Libraries\Urdf")

        # Define the target directory
        $targetDir = "com.siemens.ros-sharp\Runtime\Libraries"
        $packLibraryDir = "com.siemens.ros-sharp\Runtime";

        # Recreate the target directory
        Remove-Item -Recurse -Force $targetDir
        New-Item -ItemType Directory -Path $targetDir | Out-Null

        # Copy .cs files from the source directories to the target directories, excluding specified folders
        foreach ($sourceDir in $sourceDirs) {
            Get-ChildItem -Path $sourceDir -Recurse -File -Exclude "bin", "obj", "Properties" -Include *.cs | ForEach-Object {
                $relativePath = $_.FullName.Substring($_.FullName.IndexOf($sourceDir))
                $destination = Join-Path $packLibraryDir $relativePath
                $null = New-Item -ItemType Directory -Path (Split-Path $destination) -Force
                Copy-Item $_.FullName -Destination $destination -Force
            }
        }

        # Recursively find and delete folders named "obj" and "Properties"
        $foldersToDelete = @("obj", "Properties")
        Get-ChildItem -Path $targetDir -Recurse -Directory | Where-Object { $foldersToDelete -contains $_.Name } | ForEach-Object {
            Remove-Item $_.FullName -Recurse -Force
        }

        # Display the contents of the target directory for verification
        Get-ChildItem -Path $targetDir -Recurse
	-->
</Project>