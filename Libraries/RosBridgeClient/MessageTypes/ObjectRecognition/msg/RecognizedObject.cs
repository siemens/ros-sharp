/* 
 * This message is auto generated by ROS#. Please DO NOT modify.
 * Note:
 * - Comments from the original code will be written in their own line 
 * - Variable sized arrays will be initialized to array of size 0 
 * Please report any issues at 
 * <https://github.com/siemens/ros-sharp> 
 */



using RosSharp.RosBridgeClient.MessageTypes.Std;
using RosSharp.RosBridgeClient.MessageTypes.ObjectRecognition;
using RosSharp.RosBridgeClient.MessageTypes.Sensor;
using RosSharp.RosBridgeClient.MessageTypes.Shape;
using RosSharp.RosBridgeClient.MessageTypes.Geometry;

namespace RosSharp.RosBridgeClient.MessageTypes.ObjectRecognition
{
    public class RecognizedObject : Message
    {
        public override string RosMessageName => "object_recognition_msgs/RecognizedObject";

        // #################################################### HEADER ###########################################################
        //  The header frame corresponds to the pose frame, NOT the point_cloud frame.
        public Header header { get; set; }
        // ################################################# OBJECT INFO #########################################################
        //  Contains information about the type and the position of a found object
        //  Some of those fields might not be filled because the used techniques do not fill them or because the user does not
        //  request them
        //  The type of the found object
        public ObjectType type { get; set; }
        // confidence: how sure you are it is that object and not another one.
        //  It is between 0 and 1 and the closer to one it is the better
        public float confidence { get; set; }
        // ############################################### OBJECT CLUSTERS #######################################################
        //  Sometimes you can extract the 3d points that belong to the object, in the frames of the original sensors
        //  (it is an array as you might have several sensors)
        public PointCloud2[] point_clouds { get; set; }
        //  Sometimes, you can only provide a bounding box/shape, even in 3d
        //  This is in the pose frame
        public Mesh bounding_mesh { get; set; }
        //  Sometimes, you only have 2d input so you can't really give a pose, you just get a contour, or a box
        //  The last point will be linked to the first one automatically
        public Point[] bounding_contours { get; set; }
        // ################################################### POSE INFO #########################################################
        //  This is the result that everybody expects : the pose in some frame given with the input. The units are radian/meters
        //  as usual
        public PoseWithCovarianceStamped pose { get; set; }

        public RecognizedObject()
        {
            this.header = new Header();
            this.type = new ObjectType();
            this.confidence = 0.0f;
            this.point_clouds = new PointCloud2[0];
            this.bounding_mesh = new Mesh();
            this.bounding_contours = new Point[0];
            this.pose = new PoseWithCovarianceStamped();
        }

        public RecognizedObject(Header header, ObjectType type, float confidence, PointCloud2[] point_clouds, Mesh bounding_mesh, Point[] bounding_contours, PoseWithCovarianceStamped pose)
        {
            this.header = header;
            this.type = type;
            this.confidence = confidence;
            this.point_clouds = point_clouds;
            this.bounding_mesh = bounding_mesh;
            this.bounding_contours = bounding_contours;
            this.pose = pose;
        }
    }
}
